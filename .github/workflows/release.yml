name: Release
on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (major, minor, patch)'
        required: true
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
      manual_version:
        description: 'Manual version override (leave empty to auto-calculate based on release_type)'
        required: false
        type: string
jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Use v4
        with:
          fetch-depth: 0 # Needed for bump-my-version to potentially find tags if configured
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5 # Use v5
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install bump-my-version # Changed from bumpversion
          # pip install -e . # No longer strictly needed for just version bumping

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Get current project version from pyproject.toml
        id: project_version
        run: |
          CURRENT_PYPROJECT_VERSION=$(awk -F' = ' '/^version = ".+"/{gsub(/"/, "", $2); print $2}' pyproject.toml)
          echo "Current version from pyproject.toml: $CURRENT_PYPROJECT_VERSION"
          if [ -z "$CURRENT_PYPROJECT_VERSION" ]; then
            echo "::error::Could not read version from pyproject.toml"
            exit 1
          fi
          echo "version=$CURRENT_PYPROJECT_VERSION" >> $GITHUB_OUTPUT

      - name: Determine Next Version
        id: next_version_logic # Renamed for clarity
        run: |
          CURRENT_VERSION="${{ steps.project_version.outputs.version }}"
          NEXT_VERSION_VAL=""

          if [ ! -z "${{ github.event.inputs.manual_version }}" ]; then
            NEXT_VERSION_VAL="${{ github.event.inputs.manual_version }}"
            echo "Using manual version: $NEXT_VERSION_VAL"
          else
            # If not manual, bump-my-version will handle incrementing.
            # We just need to pass the part (major, minor, patch).
            # The actual calculation will be done by bump-my-version.
            # We can get the *prospective* next version using --dry-run --list if needed earlier,
            # but for the commit message etc., we'll get it after bump-my-version runs.
            echo "Release type for bump-my-version: ${{ github.event.inputs.release_type }}"
          fi
          echo "determined_next_version=$NEXT_VERSION_VAL" >> $GITHUB_OUTPUT # Will be empty if not manual

      - name: Update version number using bump-my-version
        id: bmv # Give this step an id to get output
        run: |
          # Set current_version for bump-my-version if not in its config,
          # or if you want to explicitly pass it.
          # The config in pyproject.toml will use this.
          export BUMPVERSION_CURRENT_VERSION="${{ steps.project_version.outputs.version }}"

          if [ ! -z "${{ steps.next_version_logic.outputs.determined_next_version }}" ]; then
            # Manual version override
            bump-my-version --new-version "${{ steps.next_version_logic.outputs.determined_next_version }}" --allow-dirty
          else
            # Auto-increment based on release_type
            bump-my-version "${{ github.event.inputs.release_type }}" --allow-dirty
          fi
          # Get the new version from pyproject.toml after bump-my-version has run
          NEW_VERSION_AFTER_BUMP=$(awk -F' = ' '/^version = ".+"/{gsub(/"/, "", $2); print $2}' pyproject.toml)
          echo "Version in pyproject.toml after bump: $NEW_VERSION_AFTER_BUMP"
          echo "new_version=$NEW_VERSION_AFTER_BUMP" >> $GITHUB_OUTPUT

      - name: Verify pyproject.toml changes
        run: |
          echo "Contents of pyproject.toml after version bump:"
          cat pyproject.toml
          echo "---"
          grep 'version = ' pyproject.toml
          grep '"Download Link" = ' pyproject.toml

      - name: Update Changelog
        run: |
          DATE=$(date +%Y-%m-%d)
          # Use the version determined by bump-my-version
          NEW_VERSION_FOR_CHANGELOG="${{ steps.bmv.outputs.new_version }}"
          NEW_ENTRY="## [$NEW_VERSION_FOR_CHANGELOG] - $DATE\n\n### Added\n- \n\n### Changed\n- \n\n### Fixed\n- \n"

          if [ ! -f "CHANGELOG.md" ]; then
            echo "::notice::Creating new CHANGELOG.md file"
            echo -e "# Changelog\n\nAll notable changes to the project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n$NEW_ENTRY" > CHANGELOG.md
          else
            cp CHANGELOG.md CHANGELOG.md.bak
            awk '/^##/{exit} {print}' CHANGELOG.md > header.tmp
            awk '/^##/{p=1} p' CHANGELOG.md > content.tmp
            cat header.tmp > CHANGELOG.md
            echo -e "\n$NEW_ENTRY" >> CHANGELOG.md
            cat content.tmp >> CHANGELOG.md
            rm header.tmp content.tmp
          fi

          echo "::notice::Updated CHANGELOG.md with new version entry for $NEW_VERSION_FOR_CHANGELOG"
          echo "First 20 lines of CHANGELOG.md:"
          head -n 20 CHANGELOG.md

      - name: Create Release Branch and PR
        run: |
          NEW_VERSION_FOR_BRANCH="${{ steps.bmv.outputs.new_version }}"
          RELEASE_BRANCH="release/v$NEW_VERSION_FOR_BRANCH"

          if git ls-remote --heads origin $RELEASE_BRANCH | grep -q $RELEASE_BRANCH; then
            echo "::warning::Branch $RELEASE_BRANCH already exists remotely. Deleting and recreating."
            git push origin --delete $RELEASE_BRANCH || true
          fi

          if git show-ref --verify --quiet refs/heads/$RELEASE_BRANCH; then
            git branch -D $RELEASE_BRANCH
          fi

          git checkout -b $RELEASE_BRANCH
          # Stage pyproject.toml, CHANGELOG.md
          # and any other files bump-my-version might have changed (e.g., __init__.py if configured)
          git add pyproject.toml CHANGELOG.md
          # Example if you also configured __init__.py for bump-my-version:
          # git add src/gtrends_cli/__init__.py

          echo "Git status after adding files:"
          git status
          git commit -m "Bump version to $NEW_VERSION_FOR_BRANCH and update changelog"
          git push -u origin $RELEASE_BRANCH --force
          echo "::notice::Created/updated release branch $RELEASE_BRANCH"

          PR_EXISTS=$(gh pr list --head $RELEASE_BRANCH --base main --json number --jq 'length')

          if [ "$PR_EXISTS" -eq "0" ]; then
            gh pr create --base main --head $RELEASE_BRANCH \
              --title "Release v$NEW_VERSION_FOR_BRANCH" \
              --body "## Release v$NEW_VERSION_FOR_BRANCH
            This PR prepares the release of version $NEW_VERSION_FOR_BRANCH.
            ### Before merging:
            - [ ] Review and update the CHANGELOG.md
            - [ ] Verify all tests pass
            - [ ] Approve the PR
            After merging, a GitHub release will automatically be created which will trigger PyPI publishing."
          else
            echo "::notice::PR for branch $RELEASE_BRANCH already exists. Skipping PR creation."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}
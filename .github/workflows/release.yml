name: Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (major, minor, patch)'
        required: true
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
      manual_version:
        description: 'Manual version override (leave empty to auto-calculate)'
        required: false
        type: string

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install bumpversion
          pip install -e .

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Get current version
        id: current
        run: |
          CURRENT_VERSION=$(grep -Po "__version__\s*=\s*[\"']\K[^\"']*" gtrends/__init__.py)
          echo "Current version: $CURRENT_VERSION"
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Calculate next version
        id: next
        run: |
          CURRENT_VERSION=${{ steps.current.outputs.current_version }}
          
          # Use manual version if provided
          if [ ! -z "${{ github.event.inputs.manual_version }}" ]; then
            NEXT_VERSION="${{ github.event.inputs.manual_version }}"
          else
            # Parse current version
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            
            # Increment based on release type
            case "${{ github.event.inputs.release_type }}" in
              major)
                NEXT_VERSION="$((MAJOR + 1)).0.0"
                ;;
              minor)
                NEXT_VERSION="$MAJOR.$((MINOR + 1)).0"
                ;;
              patch)
                NEXT_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                ;;
            esac
          fi
          
          echo "Next version: $NEXT_VERSION"
          echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT

      - name: Update version number
        run: |
          # Update version in __init__.py
          sed -i "s/__version__ = '${{ steps.current.outputs.current_version }}'/__version__ = '${{ steps.next.outputs.next_version }}'/" gtrends/__init__.py
          
          # Update version in setup.py
          sed -i "s/version=\"${{ steps.current.outputs.current_version }}\"/version=\"${{ steps.next.outputs.next_version }}\"/" setup.py

      - name: Update Changelog
        run: |
          DATE=$(date +%Y-%m-%d)
          # Prepare new changelog entry
          NEW_ENTRY="## [${{ steps.next.outputs.next_version }}] - $DATE\n\n### Added\n- \n\n### Changed\n- \n\n### Fixed\n- \n"
          
          # Insert new entry after the header
          sed -i "/^# Changelog/a\\\\n$NEW_ENTRY" CHANGELOG.md
          
          # If this is the first release, we need to create the file
          if [ ! -f "CHANGELOG.md" ]; then
            echo -e "# Changelog\n\nAll notable changes to the Google Trends CLI project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n$NEW_ENTRY" > CHANGELOG.md
          fi
          
          echo "::notice::Updated CHANGELOG.md with new version entry"
          cat CHANGELOG.md

      # Replace the "Create Release Branch" step with this updated version:
      - name: Create Release Branch
        run: |
          RELEASE_BRANCH="release/v${{ steps.next.outputs.next_version }}"
          
          # Check if branch already exists remotely
          if git ls-remote --heads origin $RELEASE_BRANCH | grep -q $RELEASE_BRANCH; then
            echo "::warning::Branch $RELEASE_BRANCH already exists remotely. Deleting and recreating."
            # Force delete the remote branch
            git push origin --delete $RELEASE_BRANCH || true
          fi
          
          # Check if branch exists locally
          if git show-ref --verify --quiet refs/heads/$RELEASE_BRANCH; then
            git branch -D $RELEASE_BRANCH
          fi
          
          # Create new branch
          git checkout -b $RELEASE_BRANCH
          
          git add gtrends/__init__.py setup.py CHANGELOG.md
          git commit -m "Bump version to ${{ steps.next.outputs.next_version }} and update changelog"
          git push -u origin $RELEASE_BRANCH --force
          
          echo "::notice::Created/updated release branch $RELEASE_BRANCH"
          
          # Check if PR already exists
          PR_EXISTS=$(gh pr list --head $RELEASE_BRANCH --base main --json number --jq 'length')
          
          if [ "$PR_EXISTS" -eq "0" ]; then
            # Create pull request if it doesn't exist
            gh pr create --base main --head $RELEASE_BRANCH \
              --title "Release v${{ steps.next.outputs.next_version }}" \
              --body "## Release v${{ steps.next.outputs.next_version }}

            This PR prepares the release of version ${{ steps.next.outputs.next_version }}.

            ### Before merging:
            - [ ] Review and update the CHANGELOG.md
            - [ ] Verify all tests pass
            - [ ] Approve the PR

            After merging, a GitHub release will automatically be created which will trigger PyPI publishing."
          else
            echo "::notice::PR for branch $RELEASE_BRANCH already exists. Skipping PR creation."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}